{"version":3,"file":"index.es.js","sources":["../src/error.ts","../src/utils.ts","../src/structs/utilities.ts","../src/structs/types.ts","../src/structs/coercions.ts","../src/struct.ts","../src/structs/refinements.ts"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\nexport type Failure = {\n  value: any\n  key: any\n  type: string\n  refinement: string | undefined\n  message: string\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\n\nexport class StructError extends TypeError {\n  value: any\n  key!: any\n  type!: string\n  refinement!: string | undefined\n  path!: Array<any>\n  branch!: Array<any>\n  failures: () => Array<Failure>;\n  [x: string]: any\n\n  constructor(failure: Failure, failures: () => Generator<Failure>) {\n    let cached: Array<Failure> | undefined\n    const { message, ...rest } = failure\n    const { path } = failure\n    const msg =\n      path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`\n    super(msg)\n    Object.assign(this, rest)\n    this.name = this.constructor.name\n    this.failures = () => {\n      return (cached ??= [failure, ...failures()])\n    }\n  }\n}\n","import { Struct, Infer, Result, Context, Describe } from './struct'\nimport { Failure } from './error'\n\n/**\n * Check if a value is an iterator.\n */\n\nfunction isIterable<T>(x: unknown): x is Iterable<T> {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function'\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isObject(x: unknown): x is object {\n  return typeof x === 'object' && x != null\n}\n\n/**\n * Check if a value is a plain object.\n */\n\nexport function isPlainObject(x: unknown): x is { [key: string]: any } {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(x)\n  return prototype === null || prototype === Object.prototype\n}\n\n/**\n * Return a value as a printable string.\n */\n\nexport function print(value: any): string {\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`\n}\n\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nexport function shiftIterator<T>(input: Iterator<T>): T | undefined {\n  const { done, value } = input.next()\n  return done ? undefined : value\n}\n\n/**\n * Convert a single validation result to a failure.\n */\n\nexport function toFailure<T, S>(\n  result: string | boolean | Partial<Failure>,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): Failure | undefined {\n  if (result === true) {\n    return\n  } else if (result === false) {\n    result = {}\n  } else if (typeof result === 'string') {\n    result = { message: result }\n  }\n\n  const { path, branch } = context\n  const { type } = struct\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${\n      refinement ? ` with refinement \\`${refinement}\\`` : ''\n    }, but received: \\`${print(value)}\\``,\n  } = result\n\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message,\n  }\n}\n\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nexport function* toFailures<T, S>(\n  result: Result,\n  context: Context,\n  struct: Struct<T, S>,\n  value: any\n): IterableIterator<Failure> {\n  if (!isIterable(result)) {\n    result = [result]\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value)\n\n    if (failure) {\n      yield failure\n    }\n  }\n}\n\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nexport function* run<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    path?: any[]\n    branch?: any[]\n    coerce?: boolean\n  } = {}\n): IterableIterator<[Failure, undefined] | [undefined, T]> {\n  const { path = [], branch = [value], coerce = false } = options\n  const ctx: Context = { path, branch }\n\n  if (coerce) {\n    value = struct.coercer(value, ctx)\n  }\n\n  let valid = true\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false\n    yield [failure, undefined]\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s as Struct, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n    })\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false\n        yield [t[0], undefined]\n      } else if (coerce) {\n        v = t[1]\n\n        if (k === undefined) {\n          value = v\n        } else if (value instanceof Map) {\n          value.set(k, v)\n        } else if (value instanceof Set) {\n          value.add(v)\n        } else if (isObject(value)) {\n          value[k] = v\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value as T, ctx)) {\n      valid = false\n      yield [failure, undefined]\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value as T]\n  }\n}\n\n/**\n * Check if a type is a tuple.\n */\n\nexport type IsTuple<T> = T extends [any]\n  ? T\n  : T extends [any, any]\n  ? T\n  : T extends [any, any, any]\n  ? T\n  : T extends [any, any, any, any]\n  ? T\n  : T extends [any, any, any, any, any]\n  ? T\n  : never\n\n/**\n * Check if a type is a record type.\n */\n\nexport type IsRecord<T> = T extends object\n  ? string extends keyof T\n    ? T\n    : never\n  : never\n\n/**\n * Check if a type is a generic string type.\n */\n\nexport type IsGenericString<T> = T extends string\n  ? string extends T\n    ? T\n    : never\n  : never\n\n/**\n * Normalize properties of a type that allow `undefined` to make them optional.\n */\n\nexport type Optionalize<S extends object> = OmitBy<S, undefined> &\n  Partial<PickBy<S, undefined>>\n\n/**\n * Omit properties from a type that extend from a specific type.\n */\n\nexport type OmitBy<T, V> = Omit<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Pick properties from a type that extend from a specific type.\n */\n\nexport type PickBy<T, V> = Pick<\n  T,\n  { [K in keyof T]: V extends Extract<T[K], V> ? K : never }[keyof T]\n>\n\n/**\n * Simplifies a type definition to its most basic representation.\n */\n\nexport type Simplify<T> = T extends any[] | Date\n  ? T\n  : { [K in keyof T]: T[K] } & {}\n\n/**\n * Assign properties from one type to another, overwriting existing.\n */\n\nexport type Assign<T, U> = Simplify<U & Omit<T, keyof U>>\n\n/**\n * A schema for object structs.\n */\n\nexport type ObjectSchema = Record<string, Struct<any, any>>\n\n/**\n * Infer a type from an object struct schema.\n */\n\nexport type ObjectType<S extends ObjectSchema> = Simplify<\n  Optionalize<{ [K in keyof S]: Infer<S[K]> }>\n>\n\n/**\n * Transform an object schema type to represent a partial.\n */\n\nexport type PartialObjectSchema<S extends ObjectSchema> = {\n  [K in keyof S]: Struct<Infer<S[K]> | undefined>\n}\n\n/**\n * A schema for any type of struct.\n */\n\nexport type StructSchema<T> = [T] extends [string]\n  ? [T] extends [IsGenericString<T>]\n    ? null\n    : EnumSchema<T>\n  : T extends\n      | number\n      | boolean\n      | bigint\n      | symbol\n      | undefined\n      | null\n      | Function\n      | Date\n      | Error\n      | RegExp\n  ? null\n  : T extends Map<any, any>\n  ? null\n  : T extends WeakMap<any, any>\n  ? null\n  : T extends Set<any>\n  ? null\n  : T extends WeakSet<any>\n  ? null\n  : T extends Array<infer E>\n  ? T extends IsTuple<T>\n    ? null\n    : Struct<E>\n  : T extends Promise<any>\n  ? null\n  : T extends object\n  ? T extends IsRecord<T>\n    ? null\n    : { [K in keyof T]: Describe<T[K]> }\n  : null\n\n/**\n * A schema for enum structs.\n */\n\nexport type EnumSchema<T extends string> = { [K in T]: K }\n\n/**\n * A schema for tuple structs.\n */\n\nexport type TupleSchema<T> = { [K in keyof T]: Struct<T[K]> }\n","import { Struct, Context, Validator } from '../struct'\nimport { object, optional } from './types'\nimport { ObjectSchema, Assign, ObjectType, PartialObjectSchema } from '../utils'\n\n/**\n * Create a new struct that combines the properties properties from multiple\n * object structs.\n *\n * Like JavaScript's `Object.assign` utility.\n */\n\nexport function assign<A extends ObjectSchema, B extends ObjectSchema>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>\n): Struct<ObjectType<Assign<A, B>>, Assign<A, B>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>\n): Struct<ObjectType<Assign<Assign<A, B>, C>>, Assign<Assign<A, B>, C>>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>\n): Struct<\n  ObjectType<Assign<Assign<Assign<A, B>, C>, D>>,\n  Assign<Assign<Assign<A, B>, C>, D>\n>\nexport function assign<\n  A extends ObjectSchema,\n  B extends ObjectSchema,\n  C extends ObjectSchema,\n  D extends ObjectSchema,\n  E extends ObjectSchema\n>(\n  A: Struct<ObjectType<A>, A>,\n  B: Struct<ObjectType<B>, B>,\n  C: Struct<ObjectType<C>, C>,\n  D: Struct<ObjectType<D>, D>,\n  E: Struct<ObjectType<E>, E>\n): Struct<\n  ObjectType<Assign<Assign<Assign<Assign<A, B>, C>, D>, E>>,\n  Assign<Assign<Assign<Assign<A, B>, C>, D>, E>\n>\nexport function assign(...Structs: Struct<any>[]): any {\n  const schemas = Structs.map((s) => s.schema)\n  const schema = Object.assign({}, ...schemas)\n  return object(schema)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n */\n\nexport function define<T>(name: string, validator: Validator): Struct<T, null> {\n  return new Struct({ type: name, schema: null, validator })\n}\n\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nexport function dynamic<T>(\n  fn: (value: unknown, ctx: Context) => Struct<T, any>\n): Struct<T, null> {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx)\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx)\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nexport function lazy<T>(fn: () => Struct<T, any>): Struct<T, null> {\n  let struct: Struct<T, any> | undefined\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ??= fn()\n      yield* struct.entries(value, ctx)\n    },\n    validator(value, ctx) {\n      struct ??= fn()\n      return struct.validator(value, ctx)\n    },\n    coercer(value, ctx) {\n      struct ??= fn()\n      return struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nexport function omit<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Omit<S, K>>, Omit<S, K>> {\n  const { schema } = struct\n  const subschema: any = { ...schema }\n\n  for (const key of keys) {\n    delete subschema[key]\n  }\n\n  return object(subschema as Omit<S, K>)\n}\n\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nexport function partial<S extends ObjectSchema>(\n  struct: Struct<ObjectType<S>, S> | S\n): Struct<ObjectType<PartialObjectSchema<S>>, PartialObjectSchema<S>> {\n  const schema: any =\n    struct instanceof Struct ? { ...struct.schema } : { ...struct }\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key])\n  }\n\n  return object(schema) as any\n}\n\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nexport function pick<S extends ObjectSchema, K extends keyof S>(\n  struct: Struct<ObjectType<S>, S>,\n  keys: K[]\n): Struct<ObjectType<Pick<S, K>>, Pick<S, K>> {\n  const { schema } = struct\n  const subschema: any = {}\n\n  for (const key of keys) {\n    subschema[key] = schema[key]\n  }\n\n  return object(subschema as Pick<S, K>)\n}\n\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nexport function struct<T>(name: string, validator: Validator): Struct<T, null> {\n  console.warn(\n    'superstruct@0.11 - The `struct` helper has been renamed to `define`.'\n  )\n\n  return define(name, validator)\n}\n","import { Infer, Struct } from '../struct'\nimport { define } from './utilities'\nimport {\n  TupleSchema,\n  ObjectSchema,\n  ObjectType,\n  print,\n  run,\n  isObject,\n} from '../utils'\n\n/**\n * Ensure that any value passes validation.\n */\n\nexport function any(): Struct<any, null> {\n  return define('any', () => true)\n}\n\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n */\n\nexport function array<T extends Struct<any>>(Element: T): Struct<Infer<T>[], T>\nexport function array(): Struct<unknown[], undefined>\nexport function array<T extends Struct<any>>(Element?: T): any {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array value, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a boolean.\n */\n\nexport function boolean(): Struct<boolean, null> {\n  return define('boolean', (value) => {\n    return typeof value === 'boolean'\n  })\n}\n\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nexport function date(): Struct<Date, null> {\n  return define('date', (value) => {\n    return (\n      (value instanceof Date && !isNaN(value.getTime())) ||\n      `Expected a valid \\`Date\\` object, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n */\n\nexport function enums<T extends number>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends string>(\n  values: readonly T[]\n): Struct<T, { [K in T[][number]]: K }>\nexport function enums<T extends number | string>(values: readonly T[]): any {\n  const schema: any = {}\n  const description = values.map((v) => print(v)).join()\n\n  for (const key of values) {\n    schema[key] = key\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return (\n        values.includes(value as any) ||\n        `Expected one of \\`${description}\\`, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a function.\n */\n\nexport function func(): Struct<Function, null> {\n  return define('func', (value) => {\n    return (\n      typeof value === 'function' ||\n      `Expected a function, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nexport function instance<T extends { new (...args: any): any }>(\n  Class: T\n): Struct<InstanceType<T>, null> {\n  return define('instance', (value) => {\n    return (\n      value instanceof Class ||\n      `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an integer.\n */\n\nexport function integer(): Struct<number, null> {\n  return define('integer', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n      `Expected an integer, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value matches all of a set of types.\n */\n\nexport function intersection<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function intersection<A, B>(\n  Structs: TupleSchema<[A, B]>\n): Struct<A & B, null>\nexport function intersection<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A & B & C, null>\nexport function intersection<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A & B & C & D, null>\nexport function intersection<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A & B & C & D & E, null>\nexport function intersection<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A & B & C & D & E & F, null>\nexport function intersection<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A & B & C & D & E & F & G, null>\nexport function intersection<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A & B & C & D & E & F & G & H, null>\nexport function intersection<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A & B & C & D & E & F & G & H & I, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A & B & C & D & E & F & G & H & I & J, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P, null>\nexport function intersection<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q,\n  null\n>\nexport function intersection(Structs: Array<Struct<any, any>>): any {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx)\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx)\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx)\n      }\n    },\n  })\n}\n\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n */\n\nexport function literal<T extends boolean>(constant: T): Struct<T, null>\nexport function literal<T extends number>(constant: T): Struct<T, null>\nexport function literal<T extends string>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): Struct<T, null>\nexport function literal<T>(constant: T): any {\n  const description = print(constant)\n  return define('literal', (value) => {\n    return (\n      value === constant ||\n      `Expected the literal \\`${description}\\`, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n */\n\nexport function map(): Struct<Map<unknown, unknown>, null>\nexport function map<K, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Map<K, V>, null>\nexport function map<K, V>(Key?: Struct<K>, Value?: Struct<V>): any {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k as string, k, Key]\n          yield [k as string, v, Value]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Map ||\n        `Expected a \\`Map\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that no value ever passes validation.\n */\n\nexport function never(): Struct<never, null> {\n  return define('never', () => false)\n}\n\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nexport function nullable<T, S>(struct: Struct<T, S>): Struct<T | null, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is a number.\n */\n\nexport function number(): Struct<number, null> {\n  return define('number', (value) => {\n    return (\n      (typeof value === 'number' && !isNaN(value)) ||\n      `Expected a number, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is an object, that is has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n */\n\nexport function object(): Struct<Record<string, unknown>, null>\nexport function object<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S>\nexport function object<S extends ObjectSchema>(schema?: S): any {\n  const knowns = schema ? Object.keys(schema) : []\n  const Never = never()\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value))\n\n        for (const key of knowns) {\n          unknowns.delete(key)\n          yield [key, value[key], schema[key]]\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n    coercer(value) {\n      return isObject(value) ? { ...value } : value\n    },\n  })\n}\n\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nexport function optional<T, S>(struct: Struct<T, S>): Struct<T | undefined, S> {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) =>\n      value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n  })\n}\n\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nexport function record<K extends string, V>(\n  Key: Struct<K>,\n  Value: Struct<V>\n): Struct<Record<K, V>, null> {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k]\n          yield [k, k, Key]\n          yield [k, v, Value]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nexport function regexp(): Struct<RegExp, null> {\n  return define('regexp', (value) => {\n    return value instanceof RegExp\n  })\n}\n\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n */\n\nexport function set(): Struct<Set<unknown>, null>\nexport function set<T>(Element: Struct<T>): Struct<Set<T>, null>\nexport function set<T>(Element?: Struct<T>): any {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v as string, v, Element]\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value\n    },\n    validator(value) {\n      return (\n        value instanceof Set ||\n        `Expected a \\`Set\\` object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value is a string.\n */\n\nexport function string(): Struct<string, null> {\n  return define('string', (value) => {\n    return (\n      typeof value === 'string' ||\n      `Expected a string, but received: ${print(value)}`\n    )\n  })\n}\n\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\n\nexport function tuple<A>(Structs: TupleSchema<[A]>): Struct<[A], null>\nexport function tuple<A, B>(Structs: TupleSchema<[A, B]>): Struct<[A, B], null>\nexport function tuple<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<[A, B, C], null>\nexport function tuple<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<[A, B, C, D], null>\nexport function tuple<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<[A, B, C, D, E], null>\nexport function tuple<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<[A, B, C, D, E, F], null>\nexport function tuple<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<[A, B, C, D, E, F, G], null>\nexport function tuple<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<[A, B, C, D, E, F, G, H], null>\nexport function tuple<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<[A, B, C, D, E, F, G, H, I], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<[A, B, C, D, E, F, G, H, I, J], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P], null>\nexport function tuple<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q], null>\nexport function tuple(Elements: Struct<any>[]): any {\n  const Never = never()\n\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length)\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        Array.isArray(value) ||\n        `Expected an array, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nexport function type<S extends ObjectSchema>(\n  schema: S\n): Struct<ObjectType<S>, S> {\n  const keys = Object.keys(schema)\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]]\n        }\n      }\n    },\n    validator(value) {\n      return (\n        isObject(value) || `Expected an object, but received: ${print(value)}`\n      )\n    },\n  })\n}\n\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nexport function union<A>(Structs: TupleSchema<[A]>): Struct<A, null>\nexport function union<A, B>(Structs: TupleSchema<[A, B]>): Struct<A | B, null>\nexport function union<A, B, C>(\n  Structs: TupleSchema<[A, B, C]>\n): Struct<A | B | C, null>\nexport function union<A, B, C, D>(\n  Structs: TupleSchema<[A, B, C, D]>\n): Struct<A | B | C | D, null>\nexport function union<A, B, C, D, E>(\n  Structs: TupleSchema<[A, B, C, D, E]>\n): Struct<A | B | C | D | E, null>\nexport function union<A, B, C, D, E, F>(\n  Structs: TupleSchema<[A, B, C, D, E, F]>\n): Struct<A | B | C | D | E | F, null>\nexport function union<A, B, C, D, E, F, G>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G]>\n): Struct<A | B | C | D | E | F | G, null>\nexport function union<A, B, C, D, E, F, G, H>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H]>\n): Struct<A | B | C | D | E | F | G | H, null>\nexport function union<A, B, C, D, E, F, G, H, I>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I]>\n): Struct<A | B | C | D | E | F | G | H | I, null>\nexport function union<A, B, C, D, E, F, G, H, I, J>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J]>\n): Struct<A | B | C | D | E | F | G | H | I | J, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P]>\n): Struct<A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P, null>\nexport function union<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  Structs: TupleSchema<[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q]>\n): Struct<\n  A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q,\n  null\n>\nexport function union(Structs: Struct<any>[]): any {\n  const description = Structs.map((s) => s.type).join(' | ')\n  return new Struct({\n    type: 'union',\n    schema: null,\n    validator(value, ctx) {\n      const failures = []\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx)\n        const [first] = tuples\n\n        if (!first[0]) {\n          return []\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure)\n            }\n          }\n        }\n      }\n\n      return [\n        `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(\n          value\n        )}`,\n        ...failures,\n      ]\n    },\n  })\n}\n\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nexport function unknown(): Struct<unknown, null> {\n  return define('unknown', () => true)\n}\n","import { Struct, is, Coercer } from '../struct'\nimport { isPlainObject } from '../utils'\nimport { string, unknown } from './types'\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function coerce<T, S, C>(\n  struct: Struct<T, S>,\n  condition: Struct<C, any>,\n  coercer: Coercer<C>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition)\n        ? struct.coercer(coercer(value, ctx), ctx)\n        : struct.coercer(value, ctx)\n    },\n  })\n}\n\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function defaulted<T, S>(\n  struct: Struct<T, S>,\n  fallback: any,\n  options: {\n    strict?: boolean\n  } = {}\n): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    const f = typeof fallback === 'function' ? fallback() : fallback\n\n    if (x === undefined) {\n      return f\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x }\n      let changed = false\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key]\n          changed = true\n        }\n      }\n\n      if (changed) {\n        return ret\n      }\n    }\n\n    return x\n  })\n}\n\n/**\n * Augment a struct to mask its input to only properties defined in the struct.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function masked<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, unknown(), (x) => {\n    if (\n      typeof struct.schema !== 'object' ||\n      struct.schema == null ||\n      typeof x !== 'object' ||\n      x == null\n    ) {\n      return x\n    } else {\n      const ret: any = {}\n\n      for (const key in struct.schema) {\n        if (key in x) {\n          ret[key] = (x as any)[key]\n        }\n      }\n\n      return ret\n    }\n  })\n}\n\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nexport function trimmed<T, S>(struct: Struct<T, S>): Struct<T, S> {\n  return coerce(struct, string(), (x) => x.trim())\n}\n","import { toFailures, shiftIterator, StructSchema, run } from './utils'\nimport { StructError, Failure } from './error'\nimport { masked } from './structs/coercions'\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nexport class Struct<T = unknown, S = unknown> {\n  readonly TYPE!: T\n  type: string\n  schema: S\n  coercer: (value: unknown, context: Context) => unknown\n  validator: (value: unknown, context: Context) => Iterable<Failure>\n  refiner: (value: T, context: Context) => Iterable<Failure>\n  entries: (\n    value: unknown,\n    context: Context\n  ) => Iterable<[string | number, unknown, Struct<any> | Struct<never>]>\n\n  constructor(props: {\n    type: string\n    schema: S\n    coercer?: Coercer\n    validator?: Validator\n    refiner?: Refiner<T>\n    entries?: Struct<T, S>['entries']\n  }) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = (value: unknown) => value,\n      entries = function* () {},\n    } = props\n\n    this.type = type\n    this.schema = schema\n    this.entries = entries\n    this.coercer = coercer\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.validator = () => []\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context)\n        return toFailures(result, context, this, value)\n      }\n    } else {\n      this.refiner = () => []\n    }\n  }\n\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n  assert(value: unknown): asserts value is T {\n    return assert(value, this)\n  }\n\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n  create(value: unknown): T {\n    return create(value, this)\n  }\n\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n  is(value: unknown): value is T {\n    return is(value, this)\n  }\n\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n  mask(value: unknown): T {\n    return mask(value, this)\n  }\n\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n  validate(\n    value: unknown,\n    options: {\n      coerce?: boolean\n    } = {}\n  ): [StructError, undefined] | [undefined, T] {\n    return validate(value, this, options)\n  }\n}\n\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nexport function assert<T, S>(\n  value: unknown,\n  struct: Struct<T, S>\n): asserts value is T {\n  const result = validate(value, struct)\n\n  if (result[0]) {\n    throw result[0]\n  }\n}\n\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nexport function create<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const result = validate(value, struct, { coerce: true })\n\n  if (result[0]) {\n    throw result[0]\n  } else {\n    return result[1]\n  }\n}\n\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nexport function mask<T, S>(value: unknown, struct: Struct<T, S>): T {\n  const M = masked(struct)\n  const ret = create(value, M)\n  return ret\n}\n\n/**\n * Check if a value passes a struct.\n */\n\nexport function is<T, S>(value: unknown, struct: Struct<T, S>): value is T {\n  const result = validate(value, struct)\n  return !result[0]\n}\n\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nexport function validate<T, S>(\n  value: unknown,\n  struct: Struct<T, S>,\n  options: {\n    coerce?: boolean\n  } = {}\n): [StructError, undefined] | [undefined, T] {\n  const tuples = run(value, struct, options)\n  const tuple = shiftIterator(tuples)!\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0]\n        }\n      }\n    })\n\n    return [error, undefined]\n  } else {\n    const v = tuple[1]\n    return [undefined, v]\n  }\n}\n\n/**\n * A `Context` contains information about the current location of the\n * validation inside the initial input value.\n */\n\nexport type Context = {\n  branch: Array<any>\n  path: Array<any>\n}\n\n/**\n * A type utility to extract the type from a `Struct` class.\n */\n\nexport type Infer<T extends Struct<any, any>> = T['TYPE']\n\n/**\n * A type utility to describe that a struct represents a TypeScript type.\n */\n\nexport type Describe<T> = Struct<T, StructSchema<T>>\n\n/**\n * A `Result` is returned from validation functions.\n */\n\nexport type Result =\n  | boolean\n  | string\n  | Partial<Failure>\n  | Iterable<boolean | string | Partial<Failure>>\n\n/**\n * A `Coercer` takes an unknown value and optionally coerces it.\n */\n\nexport type Coercer<T = unknown> = (value: T, context: Context) => unknown\n\n/**\n * A `Validator` takes an unknown value and validates it.\n */\n\nexport type Validator = (value: unknown, context: Context) => Result\n\n/**\n * A `Refiner` takes a value of a known type and validates it against a further\n * constraint.\n */\n\nexport type Refiner<T> = (value: T, context: Context) => Result\n","import { Struct, Refiner } from '../struct'\nimport { toFailures } from '../utils'\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nexport function empty<\n  T extends string | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>): Struct<T, S> {\n  const expected = `Expected an empty ${struct.type}`\n\n  return refine(struct, 'empty', (value) => {\n    if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        size === 0 || `${expected} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        length === 0 ||\n        `${expected} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nexport function max<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'max', (value) => {\n    return exclusive\n      ? value < threshold\n      : value <= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nexport function min<T extends number | Date, S extends any>(\n  struct: Struct<T, S>,\n  threshold: T,\n  options: {\n    exclusive?: boolean\n  } = {}\n): Struct<T, S> {\n  const { exclusive } = options\n  return refine(struct, 'min', (value) => {\n    return exclusive\n      ? value > threshold\n      : value >= threshold ||\n          `Expected a ${struct.type} greater than ${\n            exclusive ? '' : 'or equal to '\n          }${threshold} but received \\`${value}\\``\n  })\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nexport function pattern<T extends string, S extends any>(\n  struct: Struct<T, S>,\n  regexp: RegExp\n): Struct<T, S> {\n  return refine(struct, 'pattern', (value) => {\n    return (\n      regexp.test(value) ||\n      `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`\n    )\n  })\n}\n\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nexport function size<\n  T extends string | number | Date | any[] | Map<any, any> | Set<any>,\n  S extends any\n>(struct: Struct<T, S>, min: number, max: number = min): Struct<T, S> {\n  const expected = `Expected a ${struct.type}`\n  const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``\n\n  return refine(struct, 'size', (value) => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return (\n        (min <= value && value <= max) ||\n        `${expected} ${of} but received \\`${value}\\``\n      )\n    } else if (value instanceof Map || value instanceof Set) {\n      const { size } = value\n      return (\n        (min <= size && size <= max) ||\n        `${expected} with a size ${of} but received one with a size of \\`${size}\\``\n      )\n    } else {\n      const { length } = value as string | any[]\n      return (\n        (min <= length && length <= max) ||\n        `${expected} with a length ${of} but received one with a length of \\`${length}\\``\n      )\n    }\n  })\n}\n\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nexport function refine<T, S>(\n  struct: Struct<T, S>,\n  name: string,\n  refiner: Refiner<T>\n): Struct<T, S> {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx)\n      const result = refiner(value, ctx)\n      const failures = toFailures(result, ctx, struct, value)\n\n      for (const failure of failures) {\n        yield { ...failure, refinement: name }\n      }\n    },\n  })\n}\n"],"names":["StructError","TypeError","constructor","failure","failures","cached","message","rest","path","msg","length","join","Object","assign","name","isIterable","x","isObject","Symbol","iterator","isPlainObject","prototype","toString","call","getPrototypeOf","print","value","JSON","stringify","shiftIterator","input","done","next","undefined","toFailure","result","context","struct","branch","type","refinement","key","toFailures","r","run","options","coerce","ctx","coercer","valid","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Structs","schemas","map","schema","object","define","Struct","dynamic","fn","lazy","omit","keys","subschema","partial","optional","pick","console","warn","any","array","Element","Array","isArray","i","slice","boolean","date","Date","isNaN","getTime","enums","values","description","includes","func","instance","Class","integer","Number","isInteger","intersection","S","literal","constant","Key","Value","never","nullable","number","knowns","Never","unknowns","delete","record","regexp","RegExp","string","tuple","Elements","Math","max","union","tuples","first","push","unknown","condition","is","defaulted","fallback","f","strict","ret","changed","masked","trimmed","trim","props","assert","create","mask","validate","M","error","empty","expected","refine","size","threshold","exclusive","min","pattern","test","source","of"],"mappings":"AAAA;;;;AAcA;;;;;;;;MASaA,oBAAoBC;AAU/BC,EAAAA,YAAYC,SAAkBC;AAC5B,QAAIC,MAAJ;AACA,UAAM;AAAEC,MAAAA,OAAF;AAAW,SAAGC;AAAd,QAAuBJ,OAA7B;AACA,UAAM;AAAEK,MAAAA;AAAF,QAAWL,OAAjB;AACA,UAAMM,GAAG,GACPD,IAAI,CAACE,MAAL,KAAgB,CAAhB,GAAoBJ,OAApB,iBAA0CE,IAAI,CAACG,IAAL,CAAU,GAAV,CAA1C,YAA+DL,OADjE;AAEA,UAAMG,GAAN;AACAG,IAAAA,MAAM,CAACC,MAAP,CAAc,IAAd,EAAoBN,IAApB;AACA,SAAKO,IAAL,GAAY,KAAKZ,WAAL,CAAiBY,IAA7B;;AACA,SAAKV,QAAL,GAAgB;;;AACd,wBAAQC,MAAR,sBAAQA,MAAR,GAAmB,CAACF,OAAD,EAAU,GAAGC,QAAQ,EAArB,CAAnB;AACD,KAFD;AAGD;;;;AC1CH;;;AAIA,SAASW,UAAT,CAAuBC,CAAvB;AACE,SAAOC,QAAQ,CAACD,CAAD,CAAR,IAAe,OAAOA,CAAC,CAACE,MAAM,CAACC,QAAR,CAAR,KAA8B,UAApD;AACD;AAED;;;;;SAIgBF,SAASD;AACvB,SAAO,OAAOA,CAAP,KAAa,QAAb,IAAyBA,CAAC,IAAI,IAArC;AACD;AAED;;;;SAIgBI,cAAcJ;AAC5B,MAAIJ,MAAM,CAACS,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BP,CAA/B,MAAsC,iBAA1C,EAA6D;AAC3D,WAAO,KAAP;AACD;;AAED,QAAMK,SAAS,GAAGT,MAAM,CAACY,cAAP,CAAsBR,CAAtB,CAAlB;AACA,SAAOK,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAKT,MAAM,CAACS,SAAlD;AACD;AAED;;;;SAIgBI,MAAMC;AACpB,SAAO,OAAOA,KAAP,KAAiB,QAAjB,GAA4BC,IAAI,CAACC,SAAL,CAAeF,KAAf,CAA5B,QAAuDA,KAA9D;AACD;AAED;;;;;SAKgBG,cAAiBC;AAC/B,QAAM;AAAEC,IAAAA,IAAF;AAAQL,IAAAA;AAAR,MAAkBI,KAAK,CAACE,IAAN,EAAxB;AACA,SAAOD,IAAI,GAAGE,SAAH,GAAeP,KAA1B;AACD;AAED;;;;SAIgBQ,UACdC,QACAC,SACAC,QACAX;AAEA,MAAIS,MAAM,KAAK,IAAf,EAAqB;AACnB;AACD,GAFD,MAEO,IAAIA,MAAM,KAAK,KAAf,EAAsB;AAC3BA,IAAAA,MAAM,GAAG,EAAT;AACD,GAFM,MAEA,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AACrCA,IAAAA,MAAM,GAAG;AAAE7B,MAAAA,OAAO,EAAE6B;AAAX,KAAT;AACD;;AAED,QAAM;AAAE3B,IAAAA,IAAF;AAAQ8B,IAAAA;AAAR,MAAmBF,OAAzB;AACA,QAAM;AAAEG,IAAAA;AAAF,MAAWF,MAAjB;AACA,QAAM;AACJG,IAAAA,UADI;AAEJlC,IAAAA,OAAO,kCAAiCiC,IAAjC,UACLC,UAAU,0BAAyBA,UAAzB,SAA0C,EAD/C,0BAEcf,KAAK,CAACC,KAAD,CAFnB;AAFH,MAKFS,MALJ;AAOA,SAAO;AACLT,IAAAA,KADK;AAELa,IAAAA,IAFK;AAGLC,IAAAA,UAHK;AAILC,IAAAA,GAAG,EAAEjC,IAAI,CAACA,IAAI,CAACE,MAAL,GAAc,CAAf,CAJJ;AAKLF,IAAAA,IALK;AAML8B,IAAAA,MANK;AAOL,OAAGH,MAPE;AAQL7B,IAAAA;AARK,GAAP;AAUD;AAED;;;;UAIiBoC,WACfP,QACAC,SACAC,QACAX;AAEA,MAAI,CAACX,UAAU,CAACoB,MAAD,CAAf,EAAyB;AACvBA,IAAAA,MAAM,GAAG,CAACA,MAAD,CAAT;AACD;;AAED,OAAK,MAAMQ,CAAX,IAAgBR,MAAhB,EAAwB;AACtB,UAAMhC,OAAO,GAAG+B,SAAS,CAACS,CAAD,EAAIP,OAAJ,EAAaC,MAAb,EAAqBX,KAArB,CAAzB;;AAEA,QAAIvB,OAAJ,EAAa;AACX,YAAMA,OAAN;AACD;AACF;AACF;AAED;;;;;UAKiByC,IACflB,OACAW,QACAQ,UAII;AAEJ,QAAM;AAAErC,IAAAA,IAAI,GAAG,EAAT;AAAa8B,IAAAA,MAAM,GAAG,CAACZ,KAAD,CAAtB;AAA+BoB,IAAAA,MAAM,GAAG;AAAxC,MAAkDD,OAAxD;AACA,QAAME,GAAG,GAAY;AAAEvC,IAAAA,IAAF;AAAQ8B,IAAAA;AAAR,GAArB;;AAEA,MAAIQ,MAAJ,EAAY;AACVpB,IAAAA,KAAK,GAAGW,MAAM,CAACW,OAAP,CAAetB,KAAf,EAAsBqB,GAAtB,CAAR;AACD;;AAED,MAAIE,KAAK,GAAG,IAAZ;;AAEA,OAAK,MAAM9C,OAAX,IAAsBkC,MAAM,CAACa,SAAP,CAAiBxB,KAAjB,EAAwBqB,GAAxB,CAAtB,EAAoD;AAClDE,IAAAA,KAAK,GAAG,KAAR;AACA,UAAM,CAAC9C,OAAD,EAAU8B,SAAV,CAAN;AACD;;AAED,OAAK,IAAI,CAACkB,CAAD,EAAIC,CAAJ,EAAOC,CAAP,CAAT,IAAsBhB,MAAM,CAACiB,OAAP,CAAe5B,KAAf,EAAsBqB,GAAtB,CAAtB,EAAkD;AAChD,UAAMQ,EAAE,GAAGX,GAAG,CAACQ,CAAD,EAAIC,CAAJ,EAAiB;AAC7B7C,MAAAA,IAAI,EAAE2C,CAAC,KAAKlB,SAAN,GAAkBzB,IAAlB,GAAyB,CAAC,GAAGA,IAAJ,EAAU2C,CAAV,CADF;AAE7Bb,MAAAA,MAAM,EAAEa,CAAC,KAAKlB,SAAN,GAAkBK,MAAlB,GAA2B,CAAC,GAAGA,MAAJ,EAAYc,CAAZ,CAFN;AAG7BN,MAAAA;AAH6B,KAAjB,CAAd;;AAMA,SAAK,MAAMU,CAAX,IAAgBD,EAAhB,EAAoB;AAClB,UAAIC,CAAC,CAAC,CAAD,CAAL,EAAU;AACRP,QAAAA,KAAK,GAAG,KAAR;AACA,cAAM,CAACO,CAAC,CAAC,CAAD,CAAF,EAAOvB,SAAP,CAAN;AACD,OAHD,MAGO,IAAIa,MAAJ,EAAY;AACjBM,QAAAA,CAAC,GAAGI,CAAC,CAAC,CAAD,CAAL;;AAEA,YAAIL,CAAC,KAAKlB,SAAV,EAAqB;AACnBP,UAAAA,KAAK,GAAG0B,CAAR;AACD,SAFD,MAEO,IAAI1B,KAAK,YAAY+B,GAArB,EAA0B;AAC/B/B,UAAAA,KAAK,CAACgC,GAAN,CAAUP,CAAV,EAAaC,CAAb;AACD,SAFM,MAEA,IAAI1B,KAAK,YAAYiC,GAArB,EAA0B;AAC/BjC,UAAAA,KAAK,CAACkC,GAAN,CAAUR,CAAV;AACD,SAFM,MAEA,IAAInC,QAAQ,CAACS,KAAD,CAAZ,EAAqB;AAC1BA,UAAAA,KAAK,CAACyB,CAAD,CAAL,GAAWC,CAAX;AACD;AACF;AACF;AACF;;AAED,MAAIH,KAAJ,EAAW;AACT,SAAK,MAAM9C,OAAX,IAAsBkC,MAAM,CAACwB,OAAP,CAAenC,KAAf,EAA2BqB,GAA3B,CAAtB,EAAuD;AACrDE,MAAAA,KAAK,GAAG,KAAR;AACA,YAAM,CAAC9C,OAAD,EAAU8B,SAAV,CAAN;AACD;AACF;;AAED,MAAIgB,KAAJ,EAAW;AACT,UAAM,CAAChB,SAAD,EAAYP,KAAZ,CAAN;AACD;AACF;;SC3Heb,OAAO,GAAGiD;AACxB,QAAMC,OAAO,GAAGD,OAAO,CAACE,GAAR,CAAaX,CAAD,IAAOA,CAAC,CAACY,MAArB,CAAhB;AACA,QAAMA,MAAM,GAAGrD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,GAAGkD,OAArB,CAAf;AACA,SAAOG,MAAM,CAACD,MAAD,CAAb;AACD;AAED;;;;SAIgBE,OAAUrD,MAAcoC;AACtC,SAAO,IAAIkB,MAAJ,CAAW;AAAE7B,IAAAA,IAAI,EAAEzB,IAAR;AAAcmD,IAAAA,MAAM,EAAE,IAAtB;AAA4Bf,IAAAA;AAA5B,GAAX,CAAP;AACD;AAED;;;;;;;;SAQgBmB,QACdC;AAEA,SAAO,IAAIF,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,SADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhB,KAACX,OAAD,CAAS5B,KAAT,EAAgBqB,GAAhB;AACE,YAAMV,MAAM,GAAGiC,EAAE,CAAC5C,KAAD,EAAQqB,GAAR,CAAjB;AACA,aAAOV,MAAM,CAACiB,OAAP,CAAe5B,KAAf,EAAsBqB,GAAtB,CAAP;AACD,KANe;;AAOhBG,IAAAA,SAAS,CAACxB,KAAD,EAAQqB,GAAR;AACP,YAAMV,MAAM,GAAGiC,EAAE,CAAC5C,KAAD,EAAQqB,GAAR,CAAjB;AACA,aAAOV,MAAM,CAACa,SAAP,CAAiBxB,KAAjB,EAAwBqB,GAAxB,CAAP;AACD,KAVe;;AAWhBC,IAAAA,OAAO,CAACtB,KAAD,EAAQqB,GAAR;AACL,YAAMV,MAAM,GAAGiC,EAAE,CAAC5C,KAAD,EAAQqB,GAAR,CAAjB;AACA,aAAOV,MAAM,CAACW,OAAP,CAAetB,KAAf,EAAsBqB,GAAtB,CAAP;AACD;;AAde,GAAX,CAAP;AAgBD;AAED;;;;;;;;;SASgBwB,KAAQD;AACtB,MAAIjC,MAAJ;AACA,SAAO,IAAI+B,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,MADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhB,KAACX,OAAD,CAAS5B,KAAT,EAAgBqB,GAAhB;;;AACE,iBAAAV,MAAM,SAAN,aAAAA,MAAM,GAAKiC,EAAE,EAAb;AACA,aAAOjC,MAAM,CAACiB,OAAP,CAAe5B,KAAf,EAAsBqB,GAAtB,CAAP;AACD,KANe;;AAOhBG,IAAAA,SAAS,CAACxB,KAAD,EAAQqB,GAAR;;;AACP,kBAAAV,MAAM,SAAN,cAAAA,MAAM,GAAKiC,EAAE,EAAb;AACA,aAAOjC,MAAM,CAACa,SAAP,CAAiBxB,KAAjB,EAAwBqB,GAAxB,CAAP;AACD,KAVe;;AAWhBC,IAAAA,OAAO,CAACtB,KAAD,EAAQqB,GAAR;;;AACL,kBAAAV,MAAM,SAAN,cAAAA,MAAM,GAAKiC,EAAE,EAAb;AACA,aAAOjC,MAAM,CAACW,OAAP,CAAetB,KAAf,EAAsBqB,GAAtB,CAAP;AACD;;AAde,GAAX,CAAP;AAgBD;AAED;;;;;;;SAOgByB,KACdnC,QACAoC;AAEA,QAAM;AAAER,IAAAA;AAAF,MAAa5B,MAAnB;AACA,QAAMqC,SAAS,GAAQ,EAAE,GAAGT;AAAL,GAAvB;;AAEA,OAAK,MAAMxB,GAAX,IAAkBgC,IAAlB,EAAwB;AACtB,WAAOC,SAAS,CAACjC,GAAD,CAAhB;AACD;;AAED,SAAOyB,MAAM,CAACQ,SAAD,CAAb;AACD;AAED;;;;;;;SAOgBC,QACdtC;AAEA,QAAM4B,MAAM,GACV5B,MAAM,YAAY+B,MAAlB,GAA2B,EAAE,GAAG/B,MAAM,CAAC4B;AAAZ,GAA3B,GAAkD,EAAE,GAAG5B;AAAL,GADpD;;AAGA,OAAK,MAAMI,GAAX,IAAkBwB,MAAlB,EAA0B;AACxBA,IAAAA,MAAM,CAACxB,GAAD,CAAN,GAAcmC,QAAQ,CAACX,MAAM,CAACxB,GAAD,CAAP,CAAtB;AACD;;AAED,SAAOyB,MAAM,CAACD,MAAD,CAAb;AACD;AAED;;;;;;;SAOgBY,KACdxC,QACAoC;AAEA,QAAM;AAAER,IAAAA;AAAF,MAAa5B,MAAnB;AACA,QAAMqC,SAAS,GAAQ,EAAvB;;AAEA,OAAK,MAAMjC,GAAX,IAAkBgC,IAAlB,EAAwB;AACtBC,IAAAA,SAAS,CAACjC,GAAD,CAAT,GAAiBwB,MAAM,CAACxB,GAAD,CAAvB;AACD;;AAED,SAAOyB,MAAM,CAACQ,SAAD,CAAb;AACD;AAED;;;;;;SAMgBrC,OAAUvB,MAAcoC;AACtC4B,EAAAA,OAAO,CAACC,IAAR,CACE,sEADF;AAIA,SAAOZ,MAAM,CAACrD,IAAD,EAAOoC,SAAP,CAAb;AACD;;AC7LD;;;;SAIgB8B;AACd,SAAOb,MAAM,CAAC,KAAD,EAAQ,MAAM,IAAd,CAAb;AACD;SAYec,MAA6BC;AAC3C,SAAO,IAAId,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,OADU;AAEhB0B,IAAAA,MAAM,EAAEiB,OAFQ;;AAGhB,KAAC5B,OAAD,CAAS5B,KAAT;AACE,UAAIwD,OAAO,IAAIC,KAAK,CAACC,OAAN,CAAc1D,KAAd,CAAf,EAAqC;AACnC,aAAK,MAAM,CAAC2D,CAAD,EAAIjC,CAAJ,CAAX,IAAqB1B,KAAK,CAAC4B,OAAN,EAArB,EAAsC;AACpC,gBAAM,CAAC+B,CAAD,EAAIjC,CAAJ,EAAO8B,OAAP,CAAN;AACD;AACF;AACF,KATe;;AAUhBlC,IAAAA,OAAO,CAACtB,KAAD;AACL,aAAOyD,KAAK,CAACC,OAAN,CAAc1D,KAAd,IAAuBA,KAAK,CAAC4D,KAAN,EAAvB,GAAuC5D,KAA9C;AACD,KAZe;;AAahBwB,IAAAA,SAAS,CAACxB,KAAD;AACP,aACEyD,KAAK,CAACC,OAAN,CAAc1D,KAAd,iDAC0CD,KAAK,CAACC,KAAD,CAFjD;AAID;;AAlBe,GAAX,CAAP;AAoBD;AAED;;;;SAIgB6D;AACd,SAAOpB,MAAM,CAAC,SAAD,EAAazC,KAAD;AACvB,WAAO,OAAOA,KAAP,KAAiB,SAAxB;AACD,GAFY,CAAb;AAGD;AAED;;;;;;;SAOgB8D;AACd,SAAOrB,MAAM,CAAC,MAAD,EAAUzC,KAAD;AACpB,WACGA,KAAK,YAAY+D,IAAjB,IAAyB,CAACC,KAAK,CAAChE,KAAK,CAACiE,OAAN,EAAD,CAAhC,uDACmDlE,KAAK,CAACC,KAAD,CAF1D;AAID,GALY,CAAb;AAMD;SAeekE,MAAiCC;AAC/C,QAAM5B,MAAM,GAAQ,EAApB;AACA,QAAM6B,WAAW,GAAGD,MAAM,CAAC7B,GAAP,CAAYZ,CAAD,IAAO3B,KAAK,CAAC2B,CAAD,CAAvB,EAA4BzC,IAA5B,EAApB;;AAEA,OAAK,MAAM8B,GAAX,IAAkBoD,MAAlB,EAA0B;AACxB5B,IAAAA,MAAM,CAACxB,GAAD,CAAN,GAAcA,GAAd;AACD;;AAED,SAAO,IAAI2B,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,OADU;AAEhB0B,IAAAA,MAFgB;;AAGhBf,IAAAA,SAAS,CAACxB,KAAD;AACP,aACEmE,MAAM,CAACE,QAAP,CAAgBrE,KAAhB,2BACqBoE,WADrB,yBACqDrE,KAAK,CAACC,KAAD,CAF5D;AAID;;AARe,GAAX,CAAP;AAUD;AAED;;;;SAIgBsE;AACd,SAAO7B,MAAM,CAAC,MAAD,EAAUzC,KAAD;AACpB,WACE,OAAOA,KAAP,KAAiB,UAAjB,4CACsCD,KAAK,CAACC,KAAD,CAF7C;AAID,GALY,CAAb;AAMD;AAED;;;;SAIgBuE,SACdC;AAEA,SAAO/B,MAAM,CAAC,UAAD,EAAczC,KAAD;AACxB,WACEA,KAAK,YAAYwE,KAAjB,qBACgBA,KAAK,CAACpF,IADtB,kCACwDW,KAAK,CAACC,KAAD,CAF/D;AAID,GALY,CAAb;AAMD;AAED;;;;SAIgByE;AACd,SAAOhC,MAAM,CAAC,SAAD,EAAazC,KAAD;AACvB,WACG,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACgE,KAAK,CAAChE,KAAD,CAAnC,IAA8C0E,MAAM,CAACC,SAAP,CAAiB3E,KAAjB,CAA/C,4CACsCD,KAAK,CAACC,KAAD,CAF7C;AAID,GALY,CAAb;AAMD;SA0De4E,aAAaxC;AAC3B,SAAO,IAAIM,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,cADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhB,KAACX,OAAD,CAAS5B,KAAT,EAAgBqB,GAAhB;AACE,WAAK,MAAMwD,CAAX,IAAgBzC,OAAhB,EAAyB;AACvB,eAAOyC,CAAC,CAACjD,OAAF,CAAU5B,KAAV,EAAiBqB,GAAjB,CAAP;AACD;AACF,KAPe;;AAQhB,KAACG,SAAD,CAAWxB,KAAX,EAAkBqB,GAAlB;AACE,WAAK,MAAMwD,CAAX,IAAgBzC,OAAhB,EAAyB;AACvB,eAAOyC,CAAC,CAACrD,SAAF,CAAYxB,KAAZ,EAAmBqB,GAAnB,CAAP;AACD;AACF,KAZe;;AAahB,KAACc,OAAD,CAASnC,KAAT,EAAgBqB,GAAhB;AACE,WAAK,MAAMwD,CAAX,IAAgBzC,OAAhB,EAAyB;AACvB,eAAOyC,CAAC,CAAC1C,OAAF,CAAUnC,KAAV,EAAiBqB,GAAjB,CAAP;AACD;AACF;;AAjBe,GAAX,CAAP;AAmBD;SAUeyD,QAAWC;AACzB,QAAMX,WAAW,GAAGrE,KAAK,CAACgF,QAAD,CAAzB;AACA,SAAOtC,MAAM,CAAC,SAAD,EAAazC,KAAD;AACvB,WACEA,KAAK,KAAK+E,QAAV,+BAC0BX,WAD1B,yBAC0DrE,KAAK,CAACC,KAAD,CAFjE;AAID,GALY,CAAb;AAMD;SAYesC,IAAU0C,KAAiBC;AACzC,SAAO,IAAIvC,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,KADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhB,KAACX,OAAD,CAAS5B,KAAT;AACE,UAAIgF,GAAG,IAAIC,KAAP,IAAgBjF,KAAK,YAAY+B,GAArC,EAA0C;AACxC,aAAK,MAAM,CAACN,CAAD,EAAIC,CAAJ,CAAX,IAAqB1B,KAAK,CAAC4B,OAAN,EAArB,EAAsC;AACpC,gBAAM,CAACH,CAAD,EAAcA,CAAd,EAAiBuD,GAAjB,CAAN;AACA,gBAAM,CAACvD,CAAD,EAAcC,CAAd,EAAiBuD,KAAjB,CAAN;AACD;AACF;AACF,KAVe;;AAWhB3D,IAAAA,OAAO,CAACtB,KAAD;AACL,aAAOA,KAAK,YAAY+B,GAAjB,GAAuB,IAAIA,GAAJ,CAAQ/B,KAAR,CAAvB,GAAwCA,KAA/C;AACD,KAbe;;AAchBwB,IAAAA,SAAS,CAACxB,KAAD;AACP,aACEA,KAAK,YAAY+B,GAAjB,gDAC4ChC,KAAK,CAACC,KAAD,CAFnD;AAID;;AAnBe,GAAX,CAAP;AAqBD;AAED;;;;SAIgBkF;AACd,SAAOzC,MAAM,CAAC,OAAD,EAAU,MAAM,KAAhB,CAAb;AACD;AAED;;;;SAIgB0C,SAAexE;AAC7B,SAAO,IAAI+B,MAAJ,CAAW,EAChB,GAAG/B,MADa;AAEhBa,IAAAA,SAAS,EAAE,CAACxB,KAAD,EAAQqB,GAAR,KAAgBrB,KAAK,KAAK,IAAV,IAAkBW,MAAM,CAACa,SAAP,CAAiBxB,KAAjB,EAAwBqB,GAAxB,CAF7B;AAGhBc,IAAAA,OAAO,EAAE,CAACnC,KAAD,EAAQqB,GAAR,KAAgBrB,KAAK,KAAK,IAAV,IAAkBW,MAAM,CAACwB,OAAP,CAAenC,KAAf,EAAsBqB,GAAtB;AAH3B,GAAX,CAAP;AAKD;AAED;;;;SAIgB+D;AACd,SAAO3C,MAAM,CAAC,QAAD,EAAYzC,KAAD;AACtB,WACG,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,CAACgE,KAAK,CAAChE,KAAD,CAApC,0CACoCD,KAAK,CAACC,KAAD,CAF3C;AAID,GALY,CAAb;AAMD;SAaewC,OAA+BD;AAC7C,QAAM8C,MAAM,GAAG9C,MAAM,GAAGrD,MAAM,CAAC6D,IAAP,CAAYR,MAAZ,CAAH,GAAyB,EAA9C;AACA,QAAM+C,KAAK,GAAGJ,KAAK,EAAnB;AACA,SAAO,IAAIxC,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,QADU;AAEhB0B,IAAAA,MAAM,EAAEA,MAAM,GAAGA,MAAH,GAAY,IAFV;;AAGhB,KAACX,OAAD,CAAS5B,KAAT;AACE,UAAIuC,MAAM,IAAIhD,QAAQ,CAACS,KAAD,CAAtB,EAA+B;AAC7B,cAAMuF,QAAQ,GAAG,IAAItD,GAAJ,CAAQ/C,MAAM,CAAC6D,IAAP,CAAY/C,KAAZ,CAAR,CAAjB;;AAEA,aAAK,MAAMe,GAAX,IAAkBsE,MAAlB,EAA0B;AACxBE,UAAAA,QAAQ,CAACC,MAAT,CAAgBzE,GAAhB;AACA,gBAAM,CAACA,GAAD,EAAMf,KAAK,CAACe,GAAD,CAAX,EAAkBwB,MAAM,CAACxB,GAAD,CAAxB,CAAN;AACD;;AAED,aAAK,MAAMA,GAAX,IAAkBwE,QAAlB,EAA4B;AAC1B,gBAAM,CAACxE,GAAD,EAAMf,KAAK,CAACe,GAAD,CAAX,EAAkBuE,KAAlB,CAAN;AACD;AACF;AACF,KAhBe;;AAiBhB9D,IAAAA,SAAS,CAACxB,KAAD;AACP,aACET,QAAQ,CAACS,KAAD,CAAR,2CAAwDD,KAAK,CAACC,KAAD,CAD/D;AAGD,KArBe;;AAsBhBsB,IAAAA,OAAO,CAACtB,KAAD;AACL,aAAOT,QAAQ,CAACS,KAAD,CAAR,GAAkB,EAAE,GAAGA;AAAL,OAAlB,GAAiCA,KAAxC;AACD;;AAxBe,GAAX,CAAP;AA0BD;AAED;;;;SAIgBkD,SAAevC;AAC7B,SAAO,IAAI+B,MAAJ,CAAW,EAChB,GAAG/B,MADa;AAEhBa,IAAAA,SAAS,EAAE,CAACxB,KAAD,EAAQqB,GAAR,KACTrB,KAAK,KAAKO,SAAV,IAAuBI,MAAM,CAACa,SAAP,CAAiBxB,KAAjB,EAAwBqB,GAAxB,CAHT;AAIhBc,IAAAA,OAAO,EAAE,CAACnC,KAAD,EAAQqB,GAAR,KAAgBrB,KAAK,KAAKO,SAAV,IAAuBI,MAAM,CAACwB,OAAP,CAAenC,KAAf,EAAsBqB,GAAtB;AAJhC,GAAX,CAAP;AAMD;AAED;;;;;;;SAOgBoE,OACdT,KACAC;AAEA,SAAO,IAAIvC,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,QADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhB,KAACX,OAAD,CAAS5B,KAAT;AACE,UAAIT,QAAQ,CAACS,KAAD,CAAZ,EAAqB;AACnB,aAAK,MAAMyB,CAAX,IAAgBzB,KAAhB,EAAuB;AACrB,gBAAM0B,CAAC,GAAG1B,KAAK,CAACyB,CAAD,CAAf;AACA,gBAAM,CAACA,CAAD,EAAIA,CAAJ,EAAOuD,GAAP,CAAN;AACA,gBAAM,CAACvD,CAAD,EAAIC,CAAJ,EAAOuD,KAAP,CAAN;AACD;AACF;AACF,KAXe;;AAYhBzD,IAAAA,SAAS,CAACxB,KAAD;AACP,aACET,QAAQ,CAACS,KAAD,CAAR,2CAAwDD,KAAK,CAACC,KAAD,CAD/D;AAGD;;AAhBe,GAAX,CAAP;AAkBD;AAED;;;;;;;SAOgB0F;AACd,SAAOjD,MAAM,CAAC,QAAD,EAAYzC,KAAD;AACtB,WAAOA,KAAK,YAAY2F,MAAxB;AACD,GAFY,CAAb;AAGD;SASe3D,IAAOwB;AACrB,SAAO,IAAId,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,KADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhB,KAACX,OAAD,CAAS5B,KAAT;AACE,UAAIwD,OAAO,IAAIxD,KAAK,YAAYiC,GAAhC,EAAqC;AACnC,aAAK,MAAMP,CAAX,IAAgB1B,KAAhB,EAAuB;AACrB,gBAAM,CAAC0B,CAAD,EAAcA,CAAd,EAAiB8B,OAAjB,CAAN;AACD;AACF;AACF,KATe;;AAUhBlC,IAAAA,OAAO,CAACtB,KAAD;AACL,aAAOA,KAAK,YAAYiC,GAAjB,GAAuB,IAAIA,GAAJ,CAAQjC,KAAR,CAAvB,GAAwCA,KAA/C;AACD,KAZe;;AAahBwB,IAAAA,SAAS,CAACxB,KAAD;AACP,aACEA,KAAK,YAAYiC,GAAjB,gDAC4ClC,KAAK,CAACC,KAAD,CAFnD;AAID;;AAlBe,GAAX,CAAP;AAoBD;AAED;;;;SAIgB4F;AACd,SAAOnD,MAAM,CAAC,QAAD,EAAYzC,KAAD;AACtB,WACE,OAAOA,KAAP,KAAiB,QAAjB,0CACoCD,KAAK,CAACC,KAAD,CAF3C;AAID,GALY,CAAb;AAMD;SAsDe6F,MAAMC;AACpB,QAAMR,KAAK,GAAGJ,KAAK,EAAnB;AAEA,SAAO,IAAIxC,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,OADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhB,KAACX,OAAD,CAAS5B,KAAT;AACE,UAAIyD,KAAK,CAACC,OAAN,CAAc1D,KAAd,CAAJ,EAA0B;AACxB,cAAMhB,MAAM,GAAG+G,IAAI,CAACC,GAAL,CAASF,QAAQ,CAAC9G,MAAlB,EAA0BgB,KAAK,CAAChB,MAAhC,CAAf;;AAEA,aAAK,IAAI2E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3E,MAApB,EAA4B2E,CAAC,EAA7B,EAAiC;AAC/B,gBAAM,CAACA,CAAD,EAAI3D,KAAK,CAAC2D,CAAD,CAAT,EAAcmC,QAAQ,CAACnC,CAAD,CAAR,IAAe2B,KAA7B,CAAN;AACD;AACF;AACF,KAXe;;AAYhB9D,IAAAA,SAAS,CAACxB,KAAD;AACP,aACEyD,KAAK,CAACC,OAAN,CAAc1D,KAAd,2CACoCD,KAAK,CAACC,KAAD,CAF3C;AAID;;AAjBe,GAAX,CAAP;AAmBD;AAED;;;;;;;SAOgBa,KACd0B;AAEA,QAAMQ,IAAI,GAAG7D,MAAM,CAAC6D,IAAP,CAAYR,MAAZ,CAAb;AACA,SAAO,IAAIG,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,MADU;AAEhB0B,IAAAA,MAFgB;;AAGhB,KAACX,OAAD,CAAS5B,KAAT;AACE,UAAIT,QAAQ,CAACS,KAAD,CAAZ,EAAqB;AACnB,aAAK,MAAMyB,CAAX,IAAgBsB,IAAhB,EAAsB;AACpB,gBAAM,CAACtB,CAAD,EAAIzB,KAAK,CAACyB,CAAD,CAAT,EAAcc,MAAM,CAACd,CAAD,CAApB,CAAN;AACD;AACF;AACF,KATe;;AAUhBD,IAAAA,SAAS,CAACxB,KAAD;AACP,aACET,QAAQ,CAACS,KAAD,CAAR,2CAAwDD,KAAK,CAACC,KAAD,CAD/D;AAGD;;AAde,GAAX,CAAP;AAgBD;SAwDeiG,MAAM7D;AACpB,QAAMgC,WAAW,GAAGhC,OAAO,CAACE,GAAR,CAAaX,CAAD,IAAOA,CAAC,CAACd,IAArB,EAA2B5B,IAA3B,CAAgC,KAAhC,CAApB;AACA,SAAO,IAAIyD,MAAJ,CAAW;AAChB7B,IAAAA,IAAI,EAAE,OADU;AAEhB0B,IAAAA,MAAM,EAAE,IAFQ;;AAGhBf,IAAAA,SAAS,CAACxB,KAAD,EAAQqB,GAAR;AACP,YAAM3C,QAAQ,GAAG,EAAjB;;AAEA,WAAK,MAAMmG,CAAX,IAAgBzC,OAAhB,EAAyB;AACvB,cAAM,CAAC,GAAG8D,MAAJ,IAAchF,GAAG,CAAClB,KAAD,EAAQ6E,CAAR,EAAWxD,GAAX,CAAvB;AACA,cAAM,CAAC8E,KAAD,IAAUD,MAAhB;;AAEA,YAAI,CAACC,KAAK,CAAC,CAAD,CAAV,EAAe;AACb,iBAAO,EAAP;AACD,SAFD,MAEO;AACL,eAAK,MAAM,CAAC1H,OAAD,CAAX,IAAwByH,MAAxB,EAAgC;AAC9B,gBAAIzH,OAAJ,EAAa;AACXC,cAAAA,QAAQ,CAAC0H,IAAT,CAAc3H,OAAd;AACD;AACF;AACF;AACF;;AAED,aAAO,gDACyC2F,WADzC,yBACyErE,KAAK,CACjFC,KADiF,CAD9E,EAIL,GAAGtB,QAJE,CAAP;AAMD;;AA3Be,GAAX,CAAP;AA6BD;AAED;;;;SAIgB2H;AACd,SAAO5D,MAAM,CAAC,SAAD,EAAY,MAAM,IAAlB,CAAb;AACD;;AC3oBD;;;;;;;;;;;SAWgBrB,OACdT,QACA2F,WACAhF;AAEA,SAAO,IAAIoB,MAAJ,CAAW,EAChB,GAAG/B,MADa;AAEhBW,IAAAA,OAAO,EAAE,CAACtB,KAAD,EAAQqB,GAAR;AACP,aAAOkF,EAAE,CAACvG,KAAD,EAAQsG,SAAR,CAAF,GACH3F,MAAM,CAACW,OAAP,CAAeA,OAAO,CAACtB,KAAD,EAAQqB,GAAR,CAAtB,EAAoCA,GAApC,CADG,GAEHV,MAAM,CAACW,OAAP,CAAetB,KAAf,EAAsBqB,GAAtB,CAFJ;AAGD;AANe,GAAX,CAAP;AAQD;AAED;;;;;;;SAOgBmF,UACd7F,QACA8F,UACAtF,UAEI;AAEJ,SAAOC,MAAM,CAACT,MAAD,EAAS0F,OAAO,EAAhB,EAAqB/G,CAAD;AAC/B,UAAMoH,CAAC,GAAG,OAAOD,QAAP,KAAoB,UAApB,GAAiCA,QAAQ,EAAzC,GAA8CA,QAAxD;;AAEA,QAAInH,CAAC,KAAKiB,SAAV,EAAqB;AACnB,aAAOmG,CAAP;AACD;;AAED,QAAI,CAACvF,OAAO,CAACwF,MAAT,IAAmBjH,aAAa,CAACJ,CAAD,CAAhC,IAAuCI,aAAa,CAACgH,CAAD,CAAxD,EAA6D;AAC3D,YAAME,GAAG,GAAG,EAAE,GAAGtH;AAAL,OAAZ;AACA,UAAIuH,OAAO,GAAG,KAAd;;AAEA,WAAK,MAAM9F,GAAX,IAAkB2F,CAAlB,EAAqB;AACnB,YAAIE,GAAG,CAAC7F,GAAD,CAAH,KAAaR,SAAjB,EAA4B;AAC1BqG,UAAAA,GAAG,CAAC7F,GAAD,CAAH,GAAW2F,CAAC,CAAC3F,GAAD,CAAZ;AACA8F,UAAAA,OAAO,GAAG,IAAV;AACD;AACF;;AAED,UAAIA,OAAJ,EAAa;AACX,eAAOD,GAAP;AACD;AACF;;AAED,WAAOtH,CAAP;AACD,GAxBY,CAAb;AAyBD;AAED;;;;;;;SAOgBwH,OAAanG;AAC3B,SAAOS,MAAM,CAACT,MAAD,EAAS0F,OAAO,EAAhB,EAAqB/G,CAAD;AAC/B,QACE,OAAOqB,MAAM,CAAC4B,MAAd,KAAyB,QAAzB,IACA5B,MAAM,CAAC4B,MAAP,IAAiB,IADjB,IAEA,OAAOjD,CAAP,KAAa,QAFb,IAGAA,CAAC,IAAI,IAJP,EAKE;AACA,aAAOA,CAAP;AACD,KAPD,MAOO;AACL,YAAMsH,GAAG,GAAQ,EAAjB;;AAEA,WAAK,MAAM7F,GAAX,IAAkBJ,MAAM,CAAC4B,MAAzB,EAAiC;AAC/B,YAAIxB,GAAG,IAAIzB,CAAX,EAAc;AACZsH,UAAAA,GAAG,CAAC7F,GAAD,CAAH,GAAYzB,CAAS,CAACyB,GAAD,CAArB;AACD;AACF;;AAED,aAAO6F,GAAP;AACD;AACF,GAnBY,CAAb;AAoBD;AAED;;;;;;;SAOgBG,QAAcpG;AAC5B,SAAOS,MAAM,CAACT,MAAD,EAASiF,MAAM,EAAf,EAAoBtG,CAAD,IAAOA,CAAC,CAAC0H,IAAF,EAA1B,CAAb;AACD;;AC1GD;;;;;;MAMatE;AAYXlE,EAAAA,YAAYyI;AAQV,UAAM;AACJpG,MAAAA,IADI;AAEJ0B,MAAAA,MAFI;AAGJf,MAAAA,SAHI;AAIJW,MAAAA,OAJI;AAKJb,MAAAA,OAAO,GAAItB,KAAD,IAAoBA,KAL1B;AAMJ4B,MAAAA,OAAO,GAAG;AANN,QAOFqF,KAPJ;AASA,SAAKpG,IAAL,GAAYA,IAAZ;AACA,SAAK0B,MAAL,GAAcA,MAAd;AACA,SAAKX,OAAL,GAAeA,OAAf;AACA,SAAKN,OAAL,GAAeA,OAAf;;AAEA,QAAIE,SAAJ,EAAe;AACb,WAAKA,SAAL,GAAiB,CAACxB,KAAD,EAAQU,OAAR;AACf,cAAMD,MAAM,GAAGe,SAAS,CAACxB,KAAD,EAAQU,OAAR,CAAxB;AACA,eAAOM,UAAU,CAACP,MAAD,EAASC,OAAT,EAAkB,IAAlB,EAAwBV,KAAxB,CAAjB;AACD,OAHD;AAID,KALD,MAKO;AACL,WAAKwB,SAAL,GAAiB,MAAM,EAAvB;AACD;;AAED,QAAIW,OAAJ,EAAa;AACX,WAAKA,OAAL,GAAe,CAACnC,KAAD,EAAQU,OAAR;AACb,cAAMD,MAAM,GAAG0B,OAAO,CAACnC,KAAD,EAAQU,OAAR,CAAtB;AACA,eAAOM,UAAU,CAACP,MAAD,EAASC,OAAT,EAAkB,IAAlB,EAAwBV,KAAxB,CAAjB;AACD,OAHD;AAID,KALD,MAKO;AACL,WAAKmC,OAAL,GAAe,MAAM,EAArB;AACD;AACF;AAED;;;;;AAIA+E,EAAAA,MAAM,CAAClH,KAAD;AACJ,WAAOkH,MAAM,CAAClH,KAAD,EAAQ,IAAR,CAAb;AACD;AAED;;;;;AAIAmH,EAAAA,MAAM,CAACnH,KAAD;AACJ,WAAOmH,MAAM,CAACnH,KAAD,EAAQ,IAAR,CAAb;AACD;AAED;;;;;AAIAuG,EAAAA,EAAE,CAACvG,KAAD;AACA,WAAOuG,EAAE,CAACvG,KAAD,EAAQ,IAAR,CAAT;AACD;AAED;;;;;;AAKAoH,EAAAA,IAAI,CAACpH,KAAD;AACF,WAAOoH,IAAI,CAACpH,KAAD,EAAQ,IAAR,CAAX;AACD;AAED;;;;;;;;;;AASAqH,EAAAA,QAAQ,CACNrH,KADM,EAENmB,UAEI,EAJE;AAMN,WAAOkG,QAAQ,CAACrH,KAAD,EAAQ,IAAR,EAAcmB,OAAd,CAAf;AACD;;;AAGH;;;;SAIgB+F,OACdlH,OACAW;AAEA,QAAMF,MAAM,GAAG4G,QAAQ,CAACrH,KAAD,EAAQW,MAAR,CAAvB;;AAEA,MAAIF,MAAM,CAAC,CAAD,CAAV,EAAe;AACb,UAAMA,MAAM,CAAC,CAAD,CAAZ;AACD;AACF;AAED;;;;SAIgB0G,OAAanH,OAAgBW;AAC3C,QAAMF,MAAM,GAAG4G,QAAQ,CAACrH,KAAD,EAAQW,MAAR,EAAgB;AAAES,IAAAA,MAAM,EAAE;AAAV,GAAhB,CAAvB;;AAEA,MAAIX,MAAM,CAAC,CAAD,CAAV,EAAe;AACb,UAAMA,MAAM,CAAC,CAAD,CAAZ;AACD,GAFD,MAEO;AACL,WAAOA,MAAM,CAAC,CAAD,CAAb;AACD;AACF;AAED;;;;SAIgB2G,KAAWpH,OAAgBW;AACzC,QAAM2G,CAAC,GAAGR,MAAM,CAACnG,MAAD,CAAhB;AACA,QAAMiG,GAAG,GAAGO,MAAM,CAACnH,KAAD,EAAQsH,CAAR,CAAlB;AACA,SAAOV,GAAP;AACD;AAED;;;;SAIgBL,GAASvG,OAAgBW;AACvC,QAAMF,MAAM,GAAG4G,QAAQ,CAACrH,KAAD,EAAQW,MAAR,CAAvB;AACA,SAAO,CAACF,MAAM,CAAC,CAAD,CAAd;AACD;AAED;;;;;SAKgB4G,SACdrH,OACAW,QACAQ,UAEI;AAEJ,QAAM+E,MAAM,GAAGhF,GAAG,CAAClB,KAAD,EAAQW,MAAR,EAAgBQ,OAAhB,CAAlB;AACA,QAAM0E,KAAK,GAAG1F,aAAa,CAAC+F,MAAD,CAA3B;;AAEA,MAAIL,KAAK,CAAC,CAAD,CAAT,EAAc;AACZ,UAAM0B,KAAK,GAAG,IAAIjJ,WAAJ,CAAgBuH,KAAK,CAAC,CAAD,CAArB,EAA0B;AACtC,WAAK,MAAM/D,CAAX,IAAgBoE,MAAhB,EAAwB;AACtB,YAAIpE,CAAC,CAAC,CAAD,CAAL,EAAU;AACR,gBAAMA,CAAC,CAAC,CAAD,CAAP;AACD;AACF;AACF,KANa,CAAd;AAQA,WAAO,CAACyF,KAAD,EAAQhH,SAAR,CAAP;AACD,GAVD,MAUO;AACL,UAAMmB,CAAC,GAAGmE,KAAK,CAAC,CAAD,CAAf;AACA,WAAO,CAACtF,SAAD,EAAYmB,CAAZ,CAAP;AACD;AACF;;AC7LD;;;;SAIgB8F,MAGd7G;AACA,QAAM8G,QAAQ,0BAAwB9G,MAAM,CAACE,IAA7C;AAEA,SAAO6G,MAAM,CAAC/G,MAAD,EAAS,OAAT,EAAmBX,KAAD;AAC7B,QAAIA,KAAK,YAAY+B,GAAjB,IAAwB/B,KAAK,YAAYiC,GAA7C,EAAkD;AAChD,YAAM;AAAE0F,QAAAA;AAAF,UAAW3H,KAAjB;AACA,aACE2H,IAAI,KAAK,CAAT,IAAiBF,QAAjB,0CAA+DE,IAA/D,MADF;AAGD,KALD,MAKO;AACL,YAAM;AAAE3I,QAAAA;AAAF,UAAagB,KAAnB;AACA,aACEhB,MAAM,KAAK,CAAX,IACGyI,QADH,4CACmDzI,MADnD,MADF;AAID;AACF,GAbY,CAAb;AAcD;AAED;;;;SAIgBgH,IACdrF,QACAiH,WACAzG,UAEI;AAEJ,QAAM;AAAE0G,IAAAA;AAAF,MAAgB1G,OAAtB;AACA,SAAOuG,MAAM,CAAC/G,MAAD,EAAS,KAAT,EAAiBX,KAAD;AAC3B,WAAO6H,SAAS,GACZ7H,KAAK,GAAG4H,SADI,GAEZ5H,KAAK,IAAI4H,SAAT,oBACgBjH,MAAM,CAACE,IADvB,uBAEIgH,SAAS,GAAG,EAAH,GAAQ,cAFrB,IAGKD,SAHL,uBAGiC5H,KAHjC,MAFJ;AAMD,GAPY,CAAb;AAQD;AAED;;;;SAIgB8H,IACdnH,QACAiH,WACAzG,UAEI;AAEJ,QAAM;AAAE0G,IAAAA;AAAF,MAAgB1G,OAAtB;AACA,SAAOuG,MAAM,CAAC/G,MAAD,EAAS,KAAT,EAAiBX,KAAD;AAC3B,WAAO6H,SAAS,GACZ7H,KAAK,GAAG4H,SADI,GAEZ5H,KAAK,IAAI4H,SAAT,oBACgBjH,MAAM,CAACE,IADvB,uBAEIgH,SAAS,GAAG,EAAH,GAAQ,cAFrB,IAGKD,SAHL,uBAGiC5H,KAHjC,MAFJ;AAMD,GAPY,CAAb;AAQD;AACD;;;;SAIgB+H,QACdpH,QACA+E;AAEA,SAAOgC,MAAM,CAAC/G,MAAD,EAAS,SAAT,EAAqBX,KAAD;AAC/B,WACE0F,MAAM,CAACsC,IAAP,CAAYhI,KAAZ,qBACcW,MAAM,CAACE,IADrB,oBACyC6E,MAAM,CAACuC,MADhD,0BAC2EjI,KAD3E,OADF;AAID,GALY,CAAb;AAMD;AAED;;;;SAIgB2H,KAGdhH,QAAsBmH,KAAa9B,MAAc8B;AACjD,QAAML,QAAQ,mBAAiB9G,MAAM,CAACE,IAAtC;AACA,QAAMqH,EAAE,GAAGJ,GAAG,KAAK9B,GAAR,YAAsB8B,GAAtB,uBAA6CA,GAA7C,eAA4D9B,GAA5D,MAAX;AAEA,SAAO0B,MAAM,CAAC/G,MAAD,EAAS,MAAT,EAAkBX,KAAD;AAC5B,QAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,YAAY+D,IAAlD,EAAwD;AACtD,aACG+D,GAAG,IAAI9H,KAAP,IAAgBA,KAAK,IAAIgG,GAA1B,IACGyB,QADH,SACeS,EADf,uBACoClI,KADpC,MADF;AAID,KALD,MAKO,IAAIA,KAAK,YAAY+B,GAAjB,IAAwB/B,KAAK,YAAYiC,GAA7C,EAAkD;AACvD,YAAM;AAAE0F,QAAAA;AAAF,UAAW3H,KAAjB;AACA,aACG8H,GAAG,IAAIH,IAAP,IAAeA,IAAI,IAAI3B,GAAxB,IACGyB,QADH,qBAC2BS,EAD3B,0CACmEP,IADnE,MADF;AAID,KANM,MAMA;AACL,YAAM;AAAE3I,QAAAA;AAAF,UAAagB,KAAnB;AACA,aACG8H,GAAG,IAAI9I,MAAP,IAAiBA,MAAM,IAAIgH,GAA5B,IACGyB,QADH,uBAC6BS,EAD7B,4CACuElJ,MADvE,MADF;AAID;AACF,GAnBY,CAAb;AAoBD;AAED;;;;;;;;SAQgB0I,OACd/G,QACAvB,MACA+C;AAEA,SAAO,IAAIO,MAAJ,CAAW,EAChB,GAAG/B,MADa;;AAEhB,KAACwB,OAAD,CAASnC,KAAT,EAAgBqB,GAAhB;AACE,aAAOV,MAAM,CAACwB,OAAP,CAAenC,KAAf,EAAsBqB,GAAtB,CAAP;AACA,YAAMZ,MAAM,GAAG0B,OAAO,CAACnC,KAAD,EAAQqB,GAAR,CAAtB;AACA,YAAM3C,QAAQ,GAAGsC,UAAU,CAACP,MAAD,EAASY,GAAT,EAAcV,MAAd,EAAsBX,KAAtB,CAA3B;;AAEA,WAAK,MAAMvB,OAAX,IAAsBC,QAAtB,EAAgC;AAC9B,cAAM,EAAE,GAAGD,OAAL;AAAcqC,UAAAA,UAAU,EAAE1B;AAA1B,SAAN;AACD;AACF;;AAVe,GAAX,CAAP;AAYD;;;;"}